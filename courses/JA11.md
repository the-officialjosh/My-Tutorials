### [THE COMPLETE JAVASCRIPT COURSE - JONAS SCHMEDTMANN](https://www.udemy.com/course/the-complete-javascript-course)

- ASYNCHRONOUS JAVASCRIPT, AJAX AND APIS

<details>
<summary> 1. Synchronous Code </summary>
<br>
Synchronous Code: Code that is executed line by line in the order that it appears. Each line of code waits for the previous line to finish executing before it is executed. This is the default behavior of JavaScript. Most of the code we have written so far is synchronous code. It has a disadvantage ie Long-running operations block code execution which means that it has to wait for long codes to keep finish running before the next line is executed.
  <br>

```Javascript
// Synchronous Code
    const p = document.querySelector('.p');
    p.textContent = 'I am Josh!';
    alert('Text set!');
    p.style.color = 'red';
```

The `alert` is a example of the long-running operation. It blocks the code execution until the user `clicks` the OK button. This is a problem because the user cannot do anything else on the page until the `alert` is closed.<br>
This maybe fine but in cases for example where execution has to wait for a 5 second timer to finish running before the next line of code is executed, it becomes a problem. <br>

</details>

<details>
<summary> 2. Asynchronous Code Intros</summary>
<br>
Asynchronous Code: Code that is  executed line by line in the order that it appears. Each line of code does not wait for the previous line to finish executing before it is executed. <br>

```Javascript
// Asynchronous Code
    const p = document.querySelector('.p'); // The first line is still synchronous and we move on to the next line
    setTimeout(() => { // Here we encounter the Timeout function which will basically starts a timer in an asynchronous way. So this means that the timer will essentially run in the background without affecting the main code. We also register a callback function which will be called as soon as the timer is finished. This callback function will be called by the web API and not by the main code.
      p.textContent = 'I am Josh!';
    }, 5000); // The main code is not been blocked by the timer. It continues to run and the next line of code is executed. This is called non-blocking code.
    p.style.color = 'red';
```

Asynchronous programming is about coordinating the behaviour of a program over a period of time.<br>
As seen in the example we need a callback function to execute an asynchronous code. But that does not mean that callback functions automatically make code asynchronous.

```Javascript
[1,2,3].map(v=>v*2); // This accepts a callback function but it is still synchronous
```

Only certain functions are asynchronous like `setTimeout` and we just have to know which ones are and aren't<br>
N.B: Callback functions alone do _NOT_ make code asynchronous!

</details>

<details>
<summary> 3. Asynchronous Code Examples </summary>
<br>

```Javascript
const img = document.querySelector('.dog-img'); // This is a synchronous code
img.src = 'dog.jpg';  // This is a synchronous code - But, here we set the src attribute of any image is asynchronous as it is set in the background by the browser. The browser will download the image in the background and then set the src attribute. This is an asynchronous code.
img.addEventListener('load', function() { // Listening for the load event which is fired as soon as the image is loaded. This is an asynchronous code. As all this code is 'non-blocking' and will run in the background without affecting the main code.
  img.classList.add('fadeIn');
});
// Since we are listening once it is ready it joins the event loop and waits for the event to happen. Once the event happens the callback function is called and the code is executed.
p.style.width = '500px';
```

N.B: `addEventListener` does _NOT_ automatically make code asynchronous! for example:
<br>

```Javascript
const img = document.querySelector('.dog-img');
img.addEventListener('click', function() {
  img.classList.add('fadeIn');
});
```

<br>
This is a synchronous code because the callback function is only called when the user `clicks` on the image. So the callback function is only called when the event happens. This is not asynchronous code because the code is not running in the background. It is only running when the event happens. It is simply waiting for an `event` to happen but it is not doing anything.

Now what makes the first example asychronous is simply the fact that the image is loaded asychronously in the background and not because we are listening for the `load` event. So the code is running in the background and it is not blocking the main code.

Other examples of asynchronous code include: `Geolocation API`, `AJAX` (This is probably the most important usecase of asynchronous `JavaScript`)

More examples from my personal research includes - `Fetch API`, `Web Workers`, `IndexedDB`, `File API`, `Application Cache`, `Web Sockets`, `Server-Sent Events`, `Service Workers`, `Promises`, `Async/Await` etc.
<br>

</details>

<details>
<summary> 4. (Lectures) What are AJAX calls and APIs </summary>
<br>

##### AJAX 
`Asynchronous JavaScript` And `XML`. Allows us to communicate with remote web servers in an asynchronous way. This means that we can request data from web servers dynamically and then use that data to update the page without reloading the page. 

Say we have a client and we want to get some data from the server. We can do this by sending a request to the server. The server will then process the request and send back a response containing the data we requested. This happens asynchronously in the backgroung in a `request-response cycle`.
There can even be different types of request `GET` request to recieve data, `POST` request to send data, `PUT` request to update data, `DELETE` request to delete data etc. 

This server usually contains a `WEB API` which contains the data we are looking for.
<br>

##### API
Application Programming Interface. A piece of software that can be used by another piece of software, in order to basically allow applications to talk to each other. And this is true not just for `JavaScript` or Web development but for programming in general.

In `JavaScript` and web development, there are various types of APIs available, such as the `DOM API` and `Geolocation API`. APIs are self-contained software components that enable interaction with other software. One way to create a simple API is by implementing it in a class, where certain methods are made accessible as a public interface. Objects created from a class act as encapsulated software components that can be interacted with by other software.

The primary API discussed here is the `Online API`, which refers to an application running on a web server. It receives data requests, retrieves the requested data from a database, and sends it back to the client. These `online APIs` are commonly referred to as `APIs`, `Web APIs`, or simply `API`, as the term `Web API` is used for various other purposes as well.

Building an `Online API` involves `back-end development`, which includes working with `servers`, `databases`, and utilizing `Node.js`. Here we use third-party `APIs` that are often available for free.

There is an `API` for everything, see [PUBLIC APIs](https://github.com/public-apis/public-apis). For instance, when developing applications like a travel app, `APIs` are essential for obtaining weather data, information about destination countries, flight details, currency conversion, and even functionalities like sending emails, text messages, or embedding Google Maps. `APIs` have played a significant role in shaping the modern web, and their usage is popular in `JavaScript`.

Regarding `API` data formats, the term `AJAX` originally stood for `Asynchronous JavaScript` and `XML`.  This is also called `XMLHttpRequest` or `XHR` because the data is usually sent in the `XML` format. But nowadays we usually send data in the `JSON (JavaScript Object Notation)` format. So `AJAX` is a bit of a misnomer. `JSON` is essentially a `JavaScript` object converted to a string, which makes it easy to send across the web and use in `JavaScript` once the data is received.

 <br>
<br>

</details>

<details>
<summary> 5. How to make AJAX calls (Setup)</summary>
<br>

Here we are make a card UI component that comes from a Online API. We are going to use the `fetch` API to make AJAX calls.

The Starter Code is as follows:

index.html
```HTML
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="style.css" />
    <script defer src="script.js"></script>
    <title>Asynchronous JavaScript</title>
  </head>
  <body>
    <main class="container">
      <div class="countries">
        <!--
        <article class="country">
          <img class="country__img" src="" />
          <div class="country__data">
            <h3 class="country__name">COUNTRY</h3>
            <h4 class="country__region">REGION</h4>
            <p class="country__row"><span>üë´</span>POP people</p>
            <p class="country__row"><span>üó£Ô∏è</span>LANG</p>
            <p class="country__row"><span>üí∞</span>CUR</p>
          </div>
        </article>
        -->
      </div>
      <!-- <button class="btn-country">Where am I?</button> -->
      <div class="images"></div>
    </main>
  </body>
</html>
```

style.css
```CSS
* {
  margin: 0;
  padding: 0;
  box-sizing: inherit;
}

html {
  font-size: 62.5%;
  box-sizing: border-box;
}

body {
  font-family: system-ui;
  color: #555;
  background-color: #f7f7f7;
  min-height: 100vh;

  display: flex;
  align-items: center;
  justify-content: center;
}

.container {
  display: flex;
  flex-flow: column;
  align-items: center;
}

.countries {
  /* margin-bottom: 8rem; */
  display: flex;

  font-size: 2rem;
  opacity: 0;
  transition: opacity 1s;
}

.country {
  background-color: #fff;
  box-shadow: 0 2rem 5rem 1rem rgba(0, 0, 0, 0.1);
  font-size: 1.8rem;
  width: 30rem;
  border-radius: 0.7rem;
  margin: 0 3rem;
  /* overflow: hidden; */
}

.neighbour::before {
  content: 'Neighbour country';
  width: 100%;
  position: absolute;
  top: -4rem;

  text-align: center;
  font-size: 1.8rem;
  font-weight: 600;
  text-transform: uppercase;
  color: #888;
}

.neighbour {
  transform: scale(0.8) translateY(1rem);
  margin-left: 0;
}

.country__img {
  width: 30rem;
  height: 17rem;
  object-fit: cover;
  background-color: #eee;
  border-top-left-radius: 0.7rem;
  border-top-right-radius: 0.7rem;
}

.country__data {
  padding: 2.5rem 3.75rem 3rem 3.75rem;
}

.country__name {
  font-size: 2.7rem;
  margin-bottom: 0.7rem;
}

.country__region {
  font-size: 1.4rem;
  margin-bottom: 2.5rem;
  text-transform: uppercase;
  color: #888;
}

.country__row:not(:last-child) {
  margin-bottom: 1rem;
}

.country__row span {
  display: inline-block;
  margin-right: 2rem;
  font-size: 2.4rem;
}

.btn-country {
  border: none;
  font-size: 2rem;
  padding: 2rem 5rem;
  border-radius: 0.7rem;
  color: white;
  background-color: orangered;
  cursor: pointer;
}

.images {
  display: flex;
}

.images img {
  display: block;
  width: 80rem;
  margin: 4rem;
}

.images img.parallel {
  width: 40rem;
  margin: 2rem;
  border: 3rem solid white;
  box-shadow: 0 2rem 5rem 1rem rgba(0, 0, 0, 0.1);
}
```

and the `script.js` file is as follows:

```Javascript
'use strict';

const btn = document.querySelector('.btn-country');
const countriesContainer = document.querySelector('.countries');
```

</details>

<details>
<summary> 6. How to make AJAX calls (XMLHttpRequest)</summary>
<br>

So now we focus on the `script.js` file. There are multiple ways to make AJAX calls, but start with the old school way the `XMLHttpRequest` function.

This is a link to all [Public APIs](https://github.com/public-apis/public-apis) that you can use to practice with.

We need to check the CORS (Cross Origin Resource Sharing). As we cannot access the data from the API without it. It should be YES or Unknown. If it is NO then we cannot access the data.

```Javascript
'use strict';

const btn = document.querySelector('.btn-country');
const countriesContainer = document.querySelector('.countries');

///////////////////////////////////////

const  request = new XMLHttpRequest(); // We call first and store in variables. The is how AJAX calls used to be handled with events and callbacks. Modern way is with Promises and the Fetch API.

// + Next we need the url to do the AJAX Call
// + We get the REST COUNTRIES API from the Public APIs linked above.

// This is the API we are using. We are using the GET method and the url.
request.open('GET', 'https://restcountries.com/v3.1/name/nigeria'); //With this we basically open the request. We need to pass in the HTTP method and the url.

// We cannot just store the value in a variable. We need to listen for the load event. like this  - data = request.send(); We send the request. The AJAX call is asynchronous. So we need to wait for the data to load. We need to listen for the load event.

request.send(); // This is the method that actually sends the request.

// We need to listen for the load event.
request.addEventListener('load', function () {
  console.log(this.responseText); // The THIS keyword here is the request which means that we can replace it with request.responseText. This is the data we get back from the API.

// At this point the Console looks like this: [{"name":{"common":"Nigeria","official":"Federal Republic of Nigeria","nativeName":{"eng":{"official":"Federal Republic of Nigeria","common":"Nigeria"}}},"tld":[".ng"],"cca2":"NG","ccn3"...] - My first AJAX call üòçnand it workssssss.

//It is a JSON string. We need to convert it to an object. We can do this with the JSON.parse() method.
const [data] = JSON.parse(this.responseText); // We use array destructuring to get the first element of the array. We use the JSON.parse() method to convert the JSON string to an object. 
console.log(data); // This is the data we get back from the API. It is an object.
});

```

At this point we have the data from the API. We can now use it to display the data on the page. so we get the commented article part from the index.html file and add it to the script.js file using template literals. 


```Javascript

request.addEventListener('load', function () {
  const [data] = JSON.parse(this.responseText);
  console.log(data);

// We just replace the data from what we get from the API object already now visible in the console. So for population in the console it is in millions so we divide by a million (the underscore is a convention we learnt from earlier chapters) and then we fix to one decimal place. We also add the flag image from the API. We also add the region and the name. We also add the language and the currency.
  const html= `
      <article class="country">
   <img class="country__img" src="${data.flags.svg}" />
   <div class="country__data">
     <h3 class="country__name">${data.name.common}</h3>
     <h4 class="country__region">${data.region}</h4>
     <p class="country__row"><span>üë´</span>${(
       +data.population / 1_000_000
     ).toFixed(1)} million people</p> 
     <p class="country__row"><span>üó£Ô∏è</span>${data.languages.eng}</p>
     <p class="country__row"><span>üí∞</span>${data.currencies.NGN.name}</p>
   </div>
 </article>
  `
    // Now we need to insert the HTML into the DOM. We use the insertAdjacentHTML() method. We use the beforeend position. We pass in the html variable and the position.
  countriesContainer.insertAdjacentHTML('beforeend', html);
   // We need to set the  style of opacity of the country to 1.
  countriesContainer.style.opacity = 1;
});
```

So the one above is exactly how it should appear if you track through the console. But the one below uses a new property `Object Values` which I am seeing for the first time but it basically helps to get the values but this should work across different countries and not just NGN. 

```Javascript
 const html = `
  <article class="country">
   <img class="country__img" src="${data.flags.svg}" />
   <div class="country__data">
     <h3 class="country__name">${data.name.common}</h3>
     <h4 class="country__region">${data.region}</h4>
     <p class="country__row"><span>üë´</span>${(
       +data.population / 1_000_000
     ).toFixed(1)}M people</p> 
     <p class="country__row"><span>üó£Ô∏è</span>${
       Object.values(data.languages)[0]
     }</p>
     <p class="country__row"><span>üí∞</span>${
       Object.values(data.currencies)[0].name
     }</p>
   </div>
 </article>
 `
```
So we now have the data displaying on the page. Now to make this a function that works for all countries as expected and avoid Spaghetti code we will now refactor all into a function

```Javascript
const getCountryData = function (country) { // This takes a string as an input
const request = new XMLHttpRequest();
request.open('GET', `https://restcountries.com/v3.1/name/${country}`); // So we use the country input to make the AJAX call dynamic. We use template literals to do this.
request.send();

request.addEventListener('load', function () {
  console.log(this.responseText);
  const [data] = JSON.parse(this.responseText);
  console.log(data);

  const html = `
  <article class="country">
   <img class="country__img" src="${data.flags.svg}" />
   <div class="country__data">
     <h3 class="country__name">${data.name.common}</h3>
     <h4 class="country__region">${data.region}</h4>
     <p class="country__row"><span>üë´</span>${(
       +data.population / 1_000_000
     ).toFixed(1)}M people</p> 
     <p class="country__row"><span>üó£Ô∏è</span>${
       Object.values(data.languages)[0]
     }</p>
     <p class="country__row"><span>üí∞</span>${
       Object.values(data.currencies)[0].name
     }</p>
   </div>
 </article>
`;

  countriesContainer.insertAdjacentHTML('beforeend', html);
  countriesContainer.style.opacity = 1;
});
}
getCountryData('Nigeria'); // We call the function and pass in the country name as a string.
getCountryData('Ghana'); // Here the other country is not overwritten they just form a nice array thanks to the  .insertAdjacentHTML('beforeend' we learnt before.

// Something Interesting is when we refresh the page a couple of times the countries are not always in the same order. This is because the AJAX calls are asynchronous. Whatever AJAX call arrives first it is the one that is displayed first. So we can't really control the order in which the countries are displayed. This is a problem. But chaining can solve this
```

</details>

<details>
<summary>7. (Lectures) How The Web Works: Requests And Responses</summary>
<br>

### Quick Summary: What happens when we access a web server?

When accessing a web server, the following steps take place:

1. The browser follows a client-server architecture known as the Request-Response Cycle.
2. The URL used consists of the protocol (HTTP or HTTPS), the domain name, and the resource.
3. DNS (Domain Name Server) converts the domain name to the server's IP address.
4. A TCP/IP socket connection is established between the client and the web server.
5. HTTP (Hypertext Transfer Protocol) is used as the communication protocol.
6. An HTTP request is sent from the client to the server, including the HTTP method, request target, headers, and optional request body.
7. The server processes the request and prepares an HTTP response, including the HTTP version, status code, headers, and optional response body.
8. The response is sent back to the client, indicating the success or failure of the request.
9. Multiple requests and responses may occur when accessing a web page, as additional assets are loaded.
10. TCP breaks down requests and responses into packets, while IP handles packet routing using IP addresses.

This summary provides an overview of the steps involved in accessing a web server and the communication that takes place between the client and the server.


 <details >
  <summary><i>Full Overview</i></summary>
  <br>
  When we talked about AJAX calls we said that the browser tries to access a web server sends a request to the server and then the server sends a response back to the browser. This is called *Client Server Architecture* or *Request Response Cycle*. 

  From the URL used to get our country data.

  `https://restcountries.com/v3.1/alpha/NGA`

  #### HTTP
  We see that every URL gets an `HTTP` or `HTTPS` - *Hypertext Transfer Protocol (secure)*, which is for the protocol that will be used on this connection. Then we have the domain name, which is `restcountries.com` in this case. And then we have the resource that we want to access that's `/v3.1`.

  #### DNS
  `restcountries.com` is not the real address of the server that we're trying to access. `DNS` is a means that converts the domain name to the real address of the server which is the *IP Address*. 

  So `DNS` stands for domain name server which is a special kind of server like a phone book. So the first step that happens when we access any Web server is that the browser makes a request to a DNS which will then simply match the web address of the URL to the server's real *IP address* which is `https://161.35.252.68:443`. The *Internet service provider* makes this possible. 

  N:B: *Domain* is not the real address, the *DNS* will convert the domain to the real *IP address*. And then after the real *IP address* has been sent back to the browser, we can finally call it.

  So this is how the real address looks like `https://161.35.252.68:443`. So it still has the protocol, but then comes the *IP address* and now a *port* `(443)` which identifies a specific service that's running on a server like a sub address. This port number has nothing to do with the `/v3.1` resource that we want to access as it will actually be sent over in the HTTP request.

  #### TCP and IP
  Once we have the real *IP address*, a *TCP/IP socket connection* is established between the *client* and the *web server*. At which a connection which will last the entire time that it takes to transfer all files of the Website or all data is created.

  *TCP* is the *Transmission Control Protocol*. And *IP* is the *Internet Protocol*. They are both *communication protocols* that define exactly how data travels across the Web. They are basically the Internet's fundamental control system, as they set the rules about how data moves on the Internet.

  #### HTTP request
  Apart from *TCP/IP*, *HTTP* is another *communication protocol*. A *communication protocol* is simply a system of rules that allows two or more parties to communicate. Now in the case of *HTTP*, it's just a *protocol* that allows *clients* and *Web servers* to communicate. And that works by sending requests and response messages from *client* to *server* and back.

  Now a request message will look something like this. 

  ```bash
  GET /v3.1/alpha/NGA HTTP/1.1 # <START LINE> HTTP method + request target + HTTP version. 
  Host: restcountries.com # <HTTP REQUEST HEADERS>
  User-Agent: Mozilla/5.0 
  Accept-Language: en-US
  <BODY> # Request body is used when we want to send some data to the server eg POST request.
  ```
  The beginning of the message is the most important part called the start line. And this one contains the HTTP method that is used in the request, then the request target and the HTTP version. HTTP method: There are many available methods GET - Request, POST - Send, PUT & PATCH - Modify data, DELETE, etc. request target: where the server is to access the /v3.1/alpha resource in this case, So the URL before and now it is simply sent as the target in the HTTP request. And so then the server can figure out what to do with it. An empty target / means we would be accessing the website's route, which is just restcountries.com in this case.

  Then the next part of the request are the request headers, which is just some information that we sent about the request itself. There are many standard different headers, like what browser is used to make the request, at what time, the user's language etc.

  Now finally, in the case, we're sending data to the server. There will also be a request body, and that body will contain the data that we're sending, eg. coming from an HTML form.

  As developers we don't manually write these HTTP requests, but it's still helpful and valuable to know what they look like. The main difference between HTTP and HTTPS is that HTTPS is encrypted using TLS or SSL, which are yet some are protocols besides that, the logic behind HTTP requests and responses still applies to HTTPS.

  HTTP response
  Once the request is sent to the server, it processes the request and prepares the data or web page to be sent back. When the server is ready, it sends the response back to the client using an HTTP response. The HTTP response message resembles the request, including a start line, headers, and a body.

  ```bash
  Copy code
  HTTP/1.1 200 OK # <START LINE> HTTP version + status code + status message
  Date: Sat 01 July 2023 # <HTTP RESPONSE HEADERS>
  Content-Type: text/html
  Transfer-Encoding: chunked
  <BODY> # Response body is used when we want to send some data to the client eg JSON data.
  ```
  The start line of the response includes the version, status code, and a message. These components inform the client about the success or failure of the request. For instance, a status code of 200 indicates success, while the widely known 404 code signifies a "page not found" error. The response headers contain information about the response itself, and the response body usually contains JSON data from an API or the HTML content of a web page.

  When accessing an API, typically one request and one response are involved. However, when accessing a web page, there can be multiple requests and responses. Initially, the browser receives the HTML file, which is then scanned for additional assets like stylesheets, JavaScript files, and images. Each asset requires a separate request and results in a separate response.

  And then for each different file, there will be a new HTTP request made to the server. So basically this entire back and forth between client and server happens for every single file that is included in the Web page.
  Which means that there can be multiple requests and responses happening at the same time, but the amount is still limited because otherwise the connection would start to slow down. 

  When all the files have finally arrived, then the web page can be rendered in the browser, according to the HTML, CSS, and JavaScript specifications.

  Back to *TCP/IP* to understand how this request and response data is actually sent across the web. TCP breaks the requests and responses down into small chunks called `packets` before they are sent. Once the `packets` arrive at their destination, TCP reassembles them into the original request or response. This allows each `packet` to take a different route through the internet, ensuring quick delivery. The *IP protocol* is responsible for sending and routing these packets using *IP addresses*. 

  </details>
  <br>
  <br>
</details>

<details>
<summary>8. Welcome to Callback Hell üò≠</summary>
<br>
To recreate that same function from the Country APIs but we want it such that next country is gotten by the being bordering country to our initial country called by the first API call.  This makes the second to have to wait for the first API call to finish before it call can be rendered.  

Editing where we stopped in the previous lesson, we have:

```js
const getCountryAndNeighbour = function (country) { // We changed the name of the function to getCountryAndNeighbour
  const request = new XMLHttpRequest();
  request.open('GET', `https://restcountries.com/v3.1/name/${country}`);
  request.send();

  request.addEventListener('load', function () {
    console.log(this.responseText);
    const [data] = JSON.parse(this.responseText);
    console.log(data);

// This part is exported in a new function
  });
};
```

This would now come before the function above

```js
const renderCountry = function (data) {

    const html = `
      <article class="country">
        <img class="country__img" src="${data.flags.svg}" />
        <div class="country__data">
          <h3 class="country__name">${data.name.common}</h3>
          <h4 class="country__region">${data.region}</h4>
          <p class="country__row"><span>üë´</span>${(
            +data.population / 1_000_000
          ).toFixed(1)}M people</p> 
          <p class="country__row"><span>üó£Ô∏è</span>${
            Object.values(data.languages)[0]
          }</p>
          <p class="country__row"><span>üí∞</span>${
            Object.values(data.currencies)[0].name
          }</p>
        </div>
      </article>
`;

    countriesContainer.insertAdjacentHTML('beforeend', html);
    countriesContainer.style.opacity = 1;

}

```

Now we call the function in the load event listener

```js
//  {...
 request.addEventListener('load', function () {
    console.log(this.responseText);
    const [data] = JSON.parse(this.responseText);
    console.log(data);
    renderCountry(data);
  });
// };
  getCountryAndNeighbour('Nigeria');
  ```
  This should work!

  Now we want to get the neighbouring country of the country gotten from the first API call. We can do this by getting the country code gotten from the first API call and using it to make a second API call. 

  ```js 
  const getCountryAndNeighbour = function (country) {

  // AJAX call country 1
  const request = new XMLHttpRequest();
  request.open('GET', `https://restcountries.com/v3.1/name/${country}`);
  request.send();

  request.addEventListener('load', function () {
    console.log(this.responseText);
    const [data] = JSON.parse(this.responseText);
    renderCountry(data);

    // Get neighbour country (2)
    const neighbour = data.borders?.[0];

    // AJAX call country 2
    const request2 = new XMLHttpRequest();
    request2.open('GET', `https://restcountries.com/v3.1/alpha/${neighbour}`); // We use the neighbour gotten from the first API call and alpha to get the country code
    request2.send();
    // From this setup we can see that this request is dependent on the first request. as a nested callback function
    request2.addEventListener('load', function () {
      console.log(this.responseText); // This is the response gotten from the second API call
    });
  });
};
getCountryAndNeighbour('Nigeria');
// This works and the console displays the response gotten from the second API call which in this case is [{"name":{"common":"Benin","official":"Republic of Benin","nativeName":{"fr...
```
No matter how much were refresh the page, we would always get the same response. This is because the second API call is dependent on the first API call.

Now we want to render the second country gotten from the second API call. We can do this by copying the first rendering into in the load event listener of the second API call.

```js
    request2.addEventListener('load', function () {
      const [data2] = JSON.parse(this.responseText);
      renderCountry(data2);
    });
    // Now the second country is rendered. Wow!
```

Now there is a special class in the css for the neighbouring country so to implement that we can add a class to the html string in the renderCountry function.

```js
const renderCountry = function (data, className = '') {
  const html = `
    <article class="country ${className}">
     <img class="country__img" src="${data.flags.svg}" />
      <div class="country__data">...`

      // Now we can add the class to the second country
      request2.addEventListener('load', function () {
      const [data2] = JSON.parse(this.responseText);
      renderCountry(data2, 'neighbour');
    });
```

Now if we want to keep on getting the neighbours of the neighbour of the neighbour we will endup with a lot of nested callbacks. This is called *callback hell* which happens when we have a lot of asynchronous task that needs to be performed in a sequence. Now this happens for all asynchronous tasks that are handled by callbacks and not just AJAX calls. Example is the `setTimeout` function.


```js

  setTimeout(()=>{
    console.log('1 second passed');
    setTimeout(()=>{
      console.log('2 second passed');
      setTimeout(()=>{
        console.log('3 second passed');
        setTimeout(()=>{
          console.log('4 second passed');
        }, 1000);
      }, 1000);
    }, 1000);
  }, 1000);
```
This callback hell is very easy to identify by the triangular shape that is formed by the indentation. This is called the *pyramid of doom*. The problem is that it makes our code messy and hard to understand. It also makes it hard to handle errors, add new funtions and even maintain the code.

</details>

<details>
<summary>9. Promises and the Fetch API</summary>
<br>

The solution to callback hell is to use promises. First let's fix the callback hell in the previous lesson. We can do this by using the modern `fetch API`. 

This is how it used to be:

```js
const request = new XMLHttpRequest();
  request.open('GET', `https://restcountries.com/v3.1/name/nigeria`);
  request.send();
```

Now we need to just replace it with the fetch API

```js
const request = fetch(`https://restcountries.com/v3.1/name/nigeria`)
  console.log(response);
  
```

That's it for now. In more complex AJAX calls the fetch API can take in an array of options. But for now we will just use the url. Now the fetch API returns a promise. Which is in the console as... 

```bash
Promise¬†{<pending>}
```

Now we have a promise stored in the request variable. 

**A promise** however is defined as an object that is used as a placeholder for the future result of an asynchronous operation. *Less Formal*: A container for an asychronously delivered value. *Less Formal*: A promise is a container for a future value. Example: The response of an `AJAX` call.

Advantages of promises: We no longer rely on events and callbacks passed into asynchronous functions to handle asynchronous results. Instead of nesting callbacks, we can chain promises for a sequence of asynchronous operations: escaping callback hell. 

NB: Promises are an ES6 feature. 

Promises are time-sensitive. They can be in one of these two states:
1. Pending: Before the future value resulting from the `Async task` is available. During this time the Async task is still running in the background.
2. Settled: After the `Async task` has finished. This is when the future value is available. A settled promise can either be fulfilled (success! The Value is now available) or rejected (An error happened eg: No network).
We are able to handle these different states in our code. The promise is only settled once.

To get a result from a promise means to consume a promise. We consume a promise we already have a promise eg A promise returned by the fetch API. 
In order for a promise to  exist in the first place, it must first be built.
So it must be created in the case of the fetch API, it's the fetch function that builds the promise and returns it for us to consume. 

</details>

<details>
<summary>10. Consuming Promises</summary>

implementing the get promise in the previous lesson using the fetch API.

```js
const getCountryData = function (country){
  fetch(`https://restcountries.com/v3.1/name/${country}`)
  .then(function(response){ //The then method is available on all promises here we assume it will be called when the promise is fulfilled. 
    console.log(response);
  })
}getCountryData('Nigeria');
```
In the console so most of the information about the promise and it looks like the sample from the How Web works lesson. 

The data is in the body but we can't access it so we will need to call the json method on the response object. This will return a promise which we can then consume. 

```js
const getCountryData = function (country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then(function (response) {
      //The then method is available on all promises here we assume it will be called when the promise is fulfilled.
      console.log(response);
      return response.json(); // This also returns a promise so we can chain another then method to consume it.
    })
    .then(function (data) { // This is the data gotten from the previous then method
      console.log(data);
      renderCountry(data[0]); // We now render the country gotten from the data gotten from the previous then method.
    });
};
getCountryData('Nigeria');
//Now it gets the same data this time using two promises.
```
This works so we could refactor to look a lot cleaner.

```js
const getCountryData = function (country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then(response => response.json())
    .then(data => renderCountry(data[0]));
};
getCountryData('Nigeria');

```
Promises doesn't get rid of callbacks just callback hell.

</details>

<details>
<summary>11. Chaining Promises</summary>
<br>

To get the neighbouring country we can just chain another then method to the previous one. Now we chain two sequential AJAX call. 
```js
const getCountryData = function (country) {
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then(response => response.json())
    .then(data => {
      renderCountry(data[0]);
      const neighbour = data[0].borders?.[0];
    });
};
getCountryData('Nigeria');
// So there is no error in the console 
```

The value return is handled using `then` method whatever it is so say
```js
//...
    .then(data => {
      renderCountry(data[0]);
      const neighbour = data[0].borders?.[0];

      return 23
    }).then(x => alert(x)); // This will alert 23
};
```

Now we can use the neighbour to get the neighbouring country. 
```js
const getCountryData = function (country) {
  // Country 1
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then(response => response.json())
    .then(data => {
      renderCountry(data[0]);
      const neighbour = data[0].borders?.[0];
      // Country 2
      return fetch(`https://restcountries.com/v3.1/alpha/${neighbour}`)
    })
    .then(response => response.json())
    .then(([data]) => renderCountry(data, 'neighbour'))
};
getCountryData('Nigeria');
```
Converted to an array to get ALL the neighbours of a country will look like this:
```js
//...
const neighbours = data[0]?.borders;
      if (!neighbours) return;
      console.log(neighbours);
      // Country 2
       neighbours.forEach(neighbour => {
        return fetch(
          `https://restcountries.com/v3.1/alpha/${neighbour}
        `
        )
          .then(resonse => response.json())
          .then(([data]) => renderCountry(data, 'neighbour'));
      });
  
 ```

DO NOT DO THIS. This is called the Pyramid of Doom. This is callback hell all over again. That is chaining promises to get the neighbouring countries.

```js
 fetch(
          `https://restcountries.com/v3.1/alpha/${neighbour}
        `
        ).then(response => response.json())
```
Even this too is a callback.

We need to just return the fetch call and then chain another then method to it. 

</details>

<details>
<summary> 12. Handling Rejected Promises</summary>
<br>

Only way a user throws an error for this currently is when there is no internet connection. So we simulate this by changing the network type in the network tab of our console to offline. 

This will also be achieved by using a button. we want it to be online first and then change to offline. 

```HTML
  <!-- We uncomment this part -->
    <button class="btn-country">Where am I?</button>
```

Now we enclose the fetch call in a function and call it when the button is clicked. 

```js

btn.addEventListener('click', function () {
  getCountryData('Nigeria');
});
```
Now we click on the button and then change the network type to offline as well as disable the cache. 

```bash
Uncaught (in promise) TypeError: Failed to fetch
```
We now have an uncaught promise. As we have faied to fetch the data. We can handle this in two ways. We can pass a second callback function to the then method. This callback function will be called when the promise is rejected. 

```js
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then(response => response.json(), err => alert(err))
```
The error in the console is now gone as we actually caught/handled the error now as an alert. However seeing that we might need to handle all the errors in the same way we can just chain another then method to the previous one. 

</details>

###### I will be back to complete this section transfer from my notes.